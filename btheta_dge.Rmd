---
title: "Differential Gene Expression of B. Thetaiotamicron"
author: "Gina Vazquez"
date: "2023-11-09"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, echo=FALSE, include=FALSE}
library(SummarizedExperiment)
library(tximeta)
library(DESeq2)
library(dplyr)
library(ggplot2)
library(readr)
library(pheatmap)
library(tidyverse)
library(IHW)
library(ashr)
library(ggplot2)
library("RColorBrewer")
```

## Project Overview

-   Background into the topic
-   Why are we interested in b theta
-   what do we expect

## Project Outline

Here I am comparing the gene expression of *Bacteroides thetaiotaomicron* in two groups. Samples 275.1 - 275.5 are of a mouse gut (GRCm39) inoculated with *Clostridium Symbiosum* and *Bacteroides thetaiotaomicron VPI-5482*. Samples 278.1 - 278.5 are of a mouse gut (GRCm39) inoculated with *Clostridium symbiosum, Bacteroides thetaiotaomicron VPI-5482*, and *Salmonella enterica* serovar Typhimurium. It is expected that the gene expression of *Bacteroides thetaiotaomicron VPI-5482* will change based on the presence of *Salmonella enterica* serovar Typhimurium. 

The sequencing data used in this analysis were used in two published papers by Sebastian Winter's lab. Note that mouse microbiome samples for [Zhu et al., 2020](https://pubmed.ncbi.nlm.nih.gov/32075741/) and [Spiga et al., 2017](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5599368/) were collected and processed at the same time. These data are not all publicly available through ENA hence why the naming convention of the samples are not tied to corresponding accession numbers. The data were acquired from the lab's box link and I kept the original, in-lab naming convention. When possible, the names of the samples will be matched to the GenBank/ENA accession numbers for public availability. 

## Metatranscriptomics Summary

### Snakemake Workflow

(1) Rule fastp The fastq of the aforementioned ten samples were obtained from a raw data spreadsheet stored in a Box account held by Dr. Sebastian Winter's lab. Fastp was used to trim adapters, bases with a quality phred-score lower than 4, and reads shorter than 31 in length. It also performed base corrections during trimming. A fastq file, json file, and html file were produced for each sample.

(2) Rule filter_mouse_reads Bowtie2 was used to align the trimmed fastq files generated by the fastp rule to the index files of the mouse genome ([GRCm39](https://www.ncbi.nlm.nih.gov/datasets/genome/GCF_000001635.27/)). The index files for the mouse genome were made outside the Snakemake workflow. Reads that did not align to the mouse genome were saved as filtered fastq files.

(3) Rule align_to_microbe Bowtie2 was used to align the filtered fastq files generated by rule filter_mouse_reads to the index files for the [Bacteroides thetaiotaomicron VPI-5482 genome] (<https://www.ncbi.nlm.nih.gov/datasets/taxonomy/818/>). The index files for the microbial genome were made outside the Snakemake workflow. Reads aligning to the microbial genome were saved as a sam file.

(4) Rule convert_sam_to_sorted_bam Samtools was used to convert sam files generated by rule align_to_microbe to sorted bam files.

-   FeatureCounts was used to count transcripts that mapped to the microbial genome from the sorted bam files generated by the conver_sam_to_sorted_bam rule. It was not written as a rule in the Snakemake file because of issues with the variables. The FeatureCounts command in noted as a comment in the Snakemake file.

### Future Notes

An alternative approach:

-   Make a "master reference genome" containing all the reference genomes relevant to all samples.
-   Generate index files from the master reference genome.
-   Align all samples to these index files.
-   Generate FeatureCounts table of all reads that mapped.

Deseq2 calculates library size to determine the scaling factor for each sample based on the FeatureCounts table. Creating a FeatureCounts table with all aligned reads would retain the true library size which could effect overall conclusions.

## Deseq2 Workflow

### Read in FeatureCounts Table

```{r}
df_bth_fc = read.delim("bth_1110.txt", skip = 1, header = TRUE, row.names = 1, stringsAsFactors = FALSE)
df_bth = df_bth_fc[c("X275.1_bth.sorted.bam",	"X275.2_bth.sorted.bam",	"X275.3_bth.sorted.bam",	"X275.4_bth.sorted.bam",	"X275.5_bth.sorted.bam",	"X278.1_bth.sorted.bam",	"X278.2_bth.sorted.bam",	"X278.3_bth.sorted.bam",	"X278.4_bth.sorted.bam",	"X278.5_bth.sorted.bam")]

```

### Create a CSV of the Experimental Design 
```{r}
exp_bth = data.frame(
  Column1 = c("X275.1_bth.sorted.bam",	"X275.2_bth.sorted.bam",	"X275.3_bth.sorted.bam",	"X275.4_bth.sorted.bam",	"X275.5_bth.sorted.bam",	"X278.1_bth.sorted.bam",	"X278.2_bth.sorted.bam",	"X278.3_bth.sorted.bam",	"X278.4_bth.sorted.bam",	"X278.5_bth.sorted.bam"),
  Column2 = c("cs/bt", "cs/bt", "cs/bt", "cs/bt", "cs/bt", "cs/bt/stm", "cs/bt/stm", "cs/bt/stm", "cs/bt/stm", "cs/bt/stm" )
)
colnames(exp_bth) = c("sample", "condition")
exp_bth_path = "~/Documents/Prelim_GMMs/exp_bth.csv"
write.csv(exp_bth, file = exp_bth_path, row.names = FALSE)
csv_exp_bth = read.csv("exp_bth.csv")

csv_exp_bth
```

### DeSeq2 Object
The FeatureCounts data frame and experimental design CSV created initial are used to make the DeSeq2 object. 
```{r}
dds_bth_all = DESeqDataSetFromMatrix(countData = df_bth, colData = csv_exp_bth, design = ~ condition)
```

## Results

### Filtering out low counts and setting factor level 
I filtered out samples with counts less than 10 and set the factor level so that the cs/bt/stm group is being compared to the "mock" group cs/bt. Note on factor levels - alternatively, they can be set by using the contrast argument with *results*.

```{r, message=FALSE}
#keeping only genes with more than 10 counts
keep_bth = rowSums(counts(dds_bth_all)) >= 10
dds_bth = dds_bth_all
#dds_bth = dds_bth[keep_bth, ]

#setting factor levels
dds_bth$condition = factor(dds_bth$condition, levels = c("cs/bt","cs/bt/stm"))
```

### Differential Gene Expression 
```{r, message=FALSE}
#deseq2 results 
dds_bth = DESeq(dds_bth)
bth_res = results(dds_bth)

head(bth_res)
```

### MA Plot Without Shrinkage

```{r, echo=FALSE}
ma_data_bth = data.frame(M = bth_res$log2FoldChange, A = rowMeans(counts(dds_bth, normalized = TRUE)))
ggplot(ma_data_bth, aes(y = M, x = A)) +
  geom_point() +
  labs(y = "Log2 Fold Change (M)", x = "Average Expression (A)") +
  scale_x_continuous(trans='log10') +
  ggtitle("MA Plot for BTH Set")
```

### MA Plot with Apeglm Shrinkage

```{r, include=FALSE}
apeglm_bth = lfcShrink(dds_bth, coef="condition_cs.bt.stm_vs_cs.bt", type="apeglm")

#norm_bth = lfcShrink(dds_bth, coef=2, type="normal")

#ashr_bth = lfcShrink(dds_bth, coef=2, type="ashr")
```

```{r, echo=FALSE}
plotMA(apeglm_bth, main="apeglm")
#plotMA(norm_bth, main="norm")
#plotMA(ashr_bth, main="ashr")
```

### Normalization with Variance Stabilized Transformation
The 'vst()' function performs variance stabilized transformation on the raw count data while controlling for library size which is necessary for an MDS plot.  

```{r}
vsd_bth = vst(dds_bth)
```

### Sampe Distances
Sample distances are calculated and used for an MDS plot to compare similarity in counts between samples. 
```{r}
#sample distances
sample_dists_bth = assay(vsd_bth) %>%
  t() %>%
  dist() %>%
  as.matrix()

#MDS values from distance matrix
mds_data_bth = data.frame(cmdscale(sample_dists_bth))
mds_bth = cbind(mds_data_bth, as.data.frame(colData(vsd_bth)))
```

### MDS Plot
```{r}
ggplot(mds_bth, aes(X1, X2, shape = condition)) + 
  geom_point(size = 3) +
  theme_minimal()
```

### PCA Plot

```{r}
plotPCA(vsd_bth)
```

### HeatMap

```{r}
bth_ntd = normTransform(dds_bth)
bth_select = order(rowMeans(counts(dds_bth,normalized=TRUE)),
                   decreasing=TRUE)[1:20]
bth_heat_df = as.data.frame(colData(dds_bth)[,c("condition","sample")])  
pheatmap(assay(bth_ntd)[bth_select,], cluster_rows=FALSE, show_rownames=TRUE,
         cluster_cols=FALSE, annotation_col=bth_heat_df)
```

### HeatMap of Sample-to-Sample Distances

```{r}
bth_dist = dist(t(assay(vsd_bth)))

bth_dist_matrix = as.matrix(bth_dist)
rownames(bth_dist_matrix) = paste(vsd_bth$condition, vsd_bth$type, sep="-")
colnames(bth_dist_matrix) <- NULL
colors <- colorRampPalette( rev(brewer.pal(9, "Blues")) )(255)
pheatmap(bth_dist_matrix,
         clustering_distance_rows=bth_dist,
         clustering_distance_cols=bth_dist,
         col=colors)
```
